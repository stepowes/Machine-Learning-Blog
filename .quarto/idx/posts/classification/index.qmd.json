{"title":"Classification with KNNs","markdown":{"yaml":{"title":"Classification with KNNs","author":"Stephen Owesney","date":"2023-12-13","categories":["code","ML","classification","KNN","Confusion Matrix"],"image":"classification.png"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n\n\nClassification models play a pivotal role in assigning labels to data points, facilitating decision-making in various domains. As we delve into the nuances of classification, this blog post will explain essential metrics—Receiver Operating Characteristic (ROC) curves, Precision-Recall (PR) curves, and Confusion Matrix. Together, they offer profound insights into the performance of classification models, guiding us through the complex terrain of true positives, false positives, precision, recall, and the elusive trade-offs between them.\n\n## Understanding Relevant Classification Metrics\n\n### Receiver Operating Characteristic (ROC) Curve\n\nThe Receiver Operating Characteristic (ROC) curve is a fundamental tool in the evaluation of classification models. It illustrates the performance of a binary classifier by plotting the true positive rate against the false positive rate across various threshold settings. The curve provides valuable insights into the model's ability to distinguish between classes, specifically showcasing the trade-off between sensitivity and specificity. Understanding the ROC curve involves interpreting the area under the curve (AUC), where a higher AUC signifies superior model performance. \n\n### Precision-Recall (PR) Curve\n\nIn the landscape of classification evaluation, the Precision-Recall (PR) curve complements the insights gained from the ROC curve. Unlike the ROC curve that focuses on true positive rates and false positive rates, the PR curve emphasizes the trade-off between precision and recall. Precision, a measure of the accuracy of positive predictions, and recall, a measure of the model's ability to capture all positive instances, take center stage in the PR curve analysis. The PR curve serves as a valuable tool, especially in scenarios where imbalanced class distribution demands a closer examination of positive class prediction accuracy.\n\n### Confusion Matrix\n\nThe Confusion Matrix stands as a cornerstone in the assessment of classification model performance. Comprising four key metrics—true positives, true negatives, false positives, and false negatives—the matrix provides a comprehensive view of the model's predictive capabilities. Each cell in the matrix represents a different aspect of the model's predictions, allowing us to quantify accuracy, precision, recall, and the F1 score.\n\nAs we delve into the Confusion Matrix section, we will explore how to interpret these metrics and understand the implications for decision-making. The Confusion Matrix is an invaluable tool for gaining a nuanced understanding of a model's strengths and weaknesses, guiding us in refining our approach to classification challenges.\n\n## Applying Classification: K Nearest Neighbors (KNN)\n\nTo put these classification metrics into action, let's explore the application of the K Nearest Neighbors (KNN) algorithm—a versatile and intuitive classifier. KNN is a type of instance-based learning where a data point is classified by the majority class of its k nearest neighbors.\n\n### Dataset: Iris Flowers\n\nWe'll employ the classic Iris dataset, a well-known benchmark for classification tasks. This dataset comprises measurements of sepal length, sepal width, petal length, and petal width for three species of iris flowers—setosa, versicolor, and virginica.\n\n### KNN Implementation\n\nLet's implement the KNN classifier using the scikit-learn library and showcase the classification results with a visual representation.\n\n``` {python}\n#| code-fold: true\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.neighbors import KNeighborsClassifier\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\n\n# Load the Iris dataset (replace this with your own data loading)\niris = load_iris()\nX = iris.data\ny = iris.target\n\n# Split the data into training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Create and train the KNN classifier\nknn_classifier = KNeighborsClassifier(n_neighbors=3)  # You can adjust the number of neighbors as needed\nknn_classifier.fit(X_train, y_train)\n\n# Get predictions\ny_pred = knn_classifier.predict(X_test)\n\n# Calculate confusion matrix\ncm = confusion_matrix(y_test, y_pred)\n\n# Plot the confusion matrix using seaborn\nplt.figure(figsize=(8, 8))\nsns.heatmap(cm, annot=True, fmt='d', cmap='Blues', cbar=False, xticklabels=iris.target_names, yticklabels=iris.target_names)\nplt.title('Confusion Matrix: K Nearest Neighbors (KNN)')\nplt.xlabel('Predicted Label')\nplt.ylabel('True Label')\nplt.show()\n```\n<p style='font-size:23px'>\n\nThe confusion matrix serves as a visual representation of the performance of our K Nearest Neighbors (KNN) classifier on the Iris dataset. Each row of the matrix corresponds to the actual class, while each column represents the predicted class. The diagonal elements of the matrix indicate the number of correctly classified instances for each class. This insightful tool allows us to analyze where our classifier excels and where it may encounter challenges. By breaking down predictions into true positives, true negatives, false positives, and false negatives, we gain a nuanced understanding of the classifier's strengths and areas for improvement. This analysis forms the foundation for interpreting more advanced metrics like precision, recall, ROC curves, and PR curves, providing a comprehensive evaluation of our classification model.\n\n\nAs demonstrated through our exploration of the KNN algorithm on the Iris dataset, classification techniques provide a robust framework for decision-making in diverse domains. Whether discerning between species of flowers or making critical decisions in complex scenarios, the power of classification lies in its ability to distill patterns from data, guiding us toward informed choices. KNN is a very basic and introductory technique in classification. As we continue to refine and advance classification techniques, the role they play remain at the foundation of classification.\n\nThank you!","srcMarkdownNoYaml":"\n\n\n## Introduction\n\nClassification models play a pivotal role in assigning labels to data points, facilitating decision-making in various domains. As we delve into the nuances of classification, this blog post will explain essential metrics—Receiver Operating Characteristic (ROC) curves, Precision-Recall (PR) curves, and Confusion Matrix. Together, they offer profound insights into the performance of classification models, guiding us through the complex terrain of true positives, false positives, precision, recall, and the elusive trade-offs between them.\n\n## Understanding Relevant Classification Metrics\n\n### Receiver Operating Characteristic (ROC) Curve\n\nThe Receiver Operating Characteristic (ROC) curve is a fundamental tool in the evaluation of classification models. It illustrates the performance of a binary classifier by plotting the true positive rate against the false positive rate across various threshold settings. The curve provides valuable insights into the model's ability to distinguish between classes, specifically showcasing the trade-off between sensitivity and specificity. Understanding the ROC curve involves interpreting the area under the curve (AUC), where a higher AUC signifies superior model performance. \n\n### Precision-Recall (PR) Curve\n\nIn the landscape of classification evaluation, the Precision-Recall (PR) curve complements the insights gained from the ROC curve. Unlike the ROC curve that focuses on true positive rates and false positive rates, the PR curve emphasizes the trade-off between precision and recall. Precision, a measure of the accuracy of positive predictions, and recall, a measure of the model's ability to capture all positive instances, take center stage in the PR curve analysis. The PR curve serves as a valuable tool, especially in scenarios where imbalanced class distribution demands a closer examination of positive class prediction accuracy.\n\n### Confusion Matrix\n\nThe Confusion Matrix stands as a cornerstone in the assessment of classification model performance. Comprising four key metrics—true positives, true negatives, false positives, and false negatives—the matrix provides a comprehensive view of the model's predictive capabilities. Each cell in the matrix represents a different aspect of the model's predictions, allowing us to quantify accuracy, precision, recall, and the F1 score.\n\nAs we delve into the Confusion Matrix section, we will explore how to interpret these metrics and understand the implications for decision-making. The Confusion Matrix is an invaluable tool for gaining a nuanced understanding of a model's strengths and weaknesses, guiding us in refining our approach to classification challenges.\n\n## Applying Classification: K Nearest Neighbors (KNN)\n\nTo put these classification metrics into action, let's explore the application of the K Nearest Neighbors (KNN) algorithm—a versatile and intuitive classifier. KNN is a type of instance-based learning where a data point is classified by the majority class of its k nearest neighbors.\n\n### Dataset: Iris Flowers\n\nWe'll employ the classic Iris dataset, a well-known benchmark for classification tasks. This dataset comprises measurements of sepal length, sepal width, petal length, and petal width for three species of iris flowers—setosa, versicolor, and virginica.\n\n### KNN Implementation\n\nLet's implement the KNN classifier using the scikit-learn library and showcase the classification results with a visual representation.\n\n``` {python}\n#| code-fold: true\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.neighbors import KNeighborsClassifier\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\n\n# Load the Iris dataset (replace this with your own data loading)\niris = load_iris()\nX = iris.data\ny = iris.target\n\n# Split the data into training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Create and train the KNN classifier\nknn_classifier = KNeighborsClassifier(n_neighbors=3)  # You can adjust the number of neighbors as needed\nknn_classifier.fit(X_train, y_train)\n\n# Get predictions\ny_pred = knn_classifier.predict(X_test)\n\n# Calculate confusion matrix\ncm = confusion_matrix(y_test, y_pred)\n\n# Plot the confusion matrix using seaborn\nplt.figure(figsize=(8, 8))\nsns.heatmap(cm, annot=True, fmt='d', cmap='Blues', cbar=False, xticklabels=iris.target_names, yticklabels=iris.target_names)\nplt.title('Confusion Matrix: K Nearest Neighbors (KNN)')\nplt.xlabel('Predicted Label')\nplt.ylabel('True Label')\nplt.show()\n```\n<p style='font-size:23px'>\n\nThe confusion matrix serves as a visual representation of the performance of our K Nearest Neighbors (KNN) classifier on the Iris dataset. Each row of the matrix corresponds to the actual class, while each column represents the predicted class. The diagonal elements of the matrix indicate the number of correctly classified instances for each class. This insightful tool allows us to analyze where our classifier excels and where it may encounter challenges. By breaking down predictions into true positives, true negatives, false positives, and false negatives, we gain a nuanced understanding of the classifier's strengths and areas for improvement. This analysis forms the foundation for interpreting more advanced metrics like precision, recall, ROC curves, and PR curves, providing a comprehensive evaluation of our classification model.\n\n\nAs demonstrated through our exploration of the KNN algorithm on the Iris dataset, classification techniques provide a robust framework for decision-making in diverse domains. Whether discerning between species of flowers or making critical decisions in complex scenarios, the power of classification lies in its ability to distill patterns from data, guiding us toward informed choices. KNN is a very basic and introductory technique in classification. As we continue to refine and advance classification techniques, the role they play remain at the foundation of classification.\n\nThank you!"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","editor":"visual","theme":"cosmo","title":"Classification with KNNs","author":"Stephen Owesney","date":"2023-12-13","categories":["code","ML","classification","KNN","Confusion Matrix"],"image":"classification.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}